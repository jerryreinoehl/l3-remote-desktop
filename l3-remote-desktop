#!/usr/bin/env python3
from dataclasses import dataclass
from enum import StrEnum
from pathlib import Path

import argparse
import base64
import getpass
import json
import os
import requests
import subprocess
import sys
import yaml


@dataclass
class Context:

    username: str = None
    password: str = None
    rsa_pin: str = None
    token: str = None
    domain: str = None
    smartcard_pin: str = None
    freerdp: str = "xfreerdp3"


class UI:

    BOLD_BLACK = "1;30"
    BOLD_RED = "1;31"
    BOLD_GREEN = "1;32"
    BOLD_CYAN = "1;36"
    RED = "31"
    GREEN = "32"
    YELLOW = "33"
    BLUE = "34"
    MAGENTA = "35"
    CYAN = "36"

    def __init__(self, debug=False):
        self._debug = debug

    def print(self, s, width=None, color=None, **kwargs):
        if width:
            s = f"{s:>{width}}"

        if color:
            s = f"\x1b[{color}m{s}\x1b[0m"

        print(s, **kwargs)

    def input(self, prompt, **kwargs):
        self.print("??? " + prompt, end="", color=self.MAGENTA, flush=True, **kwargs)
        return input()

    def getpass(self, prompt, **kwargs):
        self.print("??? " + prompt, end="", color=self.MAGENTA, flush=True, **kwargs)
        return getpass.getpass(prompt="")

    def log_request(self, msg, **kwargs):
        if not self._debug:
            return
        self.print(">>> " + msg, color=self.CYAN, **kwargs)

    def log_response(self, msg, **kwargs):
        if not self._debug:
            return
        self.print("<<< " + msg, color=self.YELLOW, **kwargs)

    def log_exec(self, msg, **kwargs):
        if not self._debug:
            return
        self.print("/// " + msg, color=self.BLUE, **kwargs)

    def debug(self, msg, **kwargs):
        if not self._debug:
            return
        self.print(msg, color=self.BLUE, **kwargs)

    def info(self, msg, **kwargs):
        self.print("... " + msg, color=self.GREEN, **kwargs)

    def success(self, msg, **kwargs):
        self.print("*** " + msg, color=self.BOLD_GREEN, **kwargs)

    def error(self, msg):
        self.print("!!! " + msg, color=self.RED, file=sys.stderr)

    def fatal(self, msg, code=1):
        self.error(msg)
        exit(code)


class RDPParser:

    TYPE_INT = "i"
    TYPE_STR = "s"

    @classmethod
    def parse(cls, content: str):
        settings = RDPSessionSettings()
        settings.gateway = RDPSessionSettings.Gateway()

        for line in content.splitlines():
            # Each line should have <setting>:<type>:<value>.
            # Type is either "i" for integer or "s" for string.
            fields = line.split(":")
            if len(fields) != 3:
                continue

            key, type, value = fields
            if type == cls.TYPE_INT:
                value = int(value)

            match key:
                case "full address":
                    settings.server = value
                case "gatewayaccesstoken":
                    settings.gateway.access_token = value
                case "gatewayhostname":
                    settings.gateway.gateway = value
                case "server port":
                    settings.port = value

        return settings


class RDPSessionSettings:

    class SecurityProtocol(StrEnum):
        RDP = "rdp"
        TLS = "tls"
        NLA = "nla"
        EXT = "ext"
        AAD = "aad"

    @dataclass
    class Gateway:
        gateway: str = None
        access_token: str = None
        user: str = None
        password: str = None
        domain: str = None

    @dataclass
    class Floatbar:

        class Visibility(StrEnum):
            VISIBLE = "visible"
            HIDDEN = "hidden"

        class Show(StrEnum):
            ALWAYS = "always"
            FULLSCREEN = "fullscreen"
            WINDOW = "window"

        sticky: bool = False
        # Corresponds to /floatbar:default xfreerdp argument.
        visibility: Visibility = None
        show: Show = None

    @dataclass
    class Smartcard:
        # Redirect the smartcard devices containing any of the <str> in their
        # names `man 1 xfreerdp3`.
        devices: list[str] = None

    @dataclass
    class SmartcardLogon:
        pin: str = None

    def __init__(self):
        self.user: str = None
        self.server: str = None
        self.port: int = None
        self.domain: str = None
        self.fullscreen: bool = False
        self.clipboard: bool = False
        self.security_protocol: self.SecurityProtocol = None
        self.smartcard: self.Smartcard = None
        self.smartcard_logon: self.SmartcardLogon = None
        self.gateway: self.Gateway = None
        self.floatbar: self.Floatbar = None


class FreeRDPSession:

    def __init__(self, settings: RDPSessionSettings, freerdp_exec="xfreerdp3"):
        self._settings = settings
        self._command = None
        self._freerdp_exec = freerdp_exec

    @property
    def command(self):
        if self._command is None:
            self._command = self._generate_command()
        return self._command

    def _generate_command(self):
        cmd = [self._freerdp_exec]

        self._settings.fullscreen and cmd.append("/f")
        self._settings.clipboard and cmd.append("/clipboard")

        floatbar = self._get_floatbar_argument()
        floatbar and cmd.append(floatbar)

        if self._settings.security_protocol:
            cmd.append("/sec:" + self._settings.security_protocol.value)

        smartcard = self._get_smartcard_argument()
        smartcard and cmd.append(smartcard)

        smartcard_logon = self._get_smartcard_logon_argument()
        smartcard_logon and cmd.append(smartcard_logon)

        self._settings.user and cmd.append("/u:" + self._settings.user)
        self._settings.server and cmd.append("/v:" + self._settings.server)
        self._settings.port and cmd.append("/port:" + str(self._settings.port))
        self._settings.domain and cmd.append("/d:" + self._settings.domain)

        gateway = self._get_gateway_argument()
        gateway and cmd.append(gateway)

        return cmd

    def _get_gateway_argument(self):
        if self._settings.floatbar is None:
            return None

        args = []
        gateway = self._settings.gateway

        gateway.gateway and args.append("g:" + gateway.gateway)
        gateway.access_token and args.append("access-token:" + gateway.access_token)
        gateway.user and args.append("u:" + gateway.user)
        gateway.password and args.append("p:" + gateway.password)
        gateway.domain and args.append("d:" + gateway.domain)

        if not args:
            return None

        return "/gateway:" + ",".join(args)

    def _get_floatbar_argument(self):
        if self._settings.floatbar is None:
            return None

        args = []
        floatbar = self._settings.floatbar

        if floatbar.sticky is not None:
            args.append("sticky:" + ("on" if floatbar.sticky else "off"))

        if floatbar.visibility is not None:
            args.append("default:" + floatbar.visibility.value)

        if floatbar.show is not None:
            args.append("show:" + floatbar.show.value)

        if not args:
            return None

        return "/floatbar:" + ",".join(args)

    def _get_smartcard_argument(self):
        if self._settings.smartcard is None:
            return None

        smartcard = self._settings.smartcard
        arg = "/smartcard"
        if smartcard.devices:
            arg += ":" + ",".join(smartcard.devices)

        return arg

    def _get_smartcard_logon_argument(self):
        if self._settings.smartcard_logon is None:
            return None

        smartcard_logon = self._settings.smartcard_logon
        args = []

        smartcard_logon.pin and args.append("pin:" + smartcard_logon.pin)

        arg = "/smartcard-logon"
        if args:
            arg += ":" + ",".join(args)

        return arg

    def launch(self):
        p = subprocess.Popen(self.command)
        p.wait()


class PortalSession:

    class PortalSessionError(RuntimeError): ...

    class InitializationError(PortalSessionError): ...

    class AuthenticationError(PortalSessionError): ...

    class RDPRequestError(PortalSessionError): ...

    @dataclass
    class AuthenticationInfo:
        username: str
        password: str
        pin: str
        token: str
        vhost: str = "standard"

    def __init__(self, domain, cache: Path = None):
        self._session = requests.Session()
        self._domain = domain
        self._cache = cache
        self._log_req_cb = None
        self._log_res_cb = None
        self._authentication_info_cb = self._get_authentication_info

    def _get_authentication_info(self):
        username = input("Username: ")
        password = getpass.getpass("Password: ")
        pin = getpass.getpass("Pin: ")
        token = input("Token: ")

        return self.AuthenticationInfo(username, password, pin, token)

    def log_request(self, request):
        if not self._log_req_cb:
            return

        self._log_req_cb(f"{request.method} {request.url}")
        for k, v in request.headers.items():
            self._log_req_cb(f"{k}: {v}")

    def log_response(self, response, log_content=False):
        if not self._log_res_cb:
            return

        self._log_res_cb(f"[{response.status_code} {response.reason}] {response.url}")
        for k, v in response.headers.items():
            self._log_res_cb(f"{k}: {v}")

        if log_content:
            self._log_res_cb("")
            for line in response.content.decode().splitlines():
                self._log_res_cb(line)

    def set_log_request_callback(self, log_req_cb):
        self._log_req_cb = log_req_cb

    def set_log_response_callback(self, log_res_cb):
        self._log_res_cb = log_res_cb

    def set_authentication_info_callback(self, authentication_info_cb):
        self._authentication_info_cb = authentication_info_cb

    def initialize(self):
        url = "https://portal.l3t.com/"

        req = requests.Request("GET", url)
        req = self._session.prepare_request(req)

        self.log_request(req)

        res = self._session.send(req)

        self.log_response(res)

        if not res.ok:
            raise self.InitializationError()

    def authenticate(self):
        url = "https://portal.l3t.com/my.policy"
        auth = self._authentication_info_cb()

        data = dict(
            username=auth.username,
            password=auth.password,
            rsapassword=auth.pin + auth.token,
            vhost=auth.vhost,
        )

        req = requests.Request("POST", url, data=data)
        req = self._session.prepare_request(req)

        self.log_request(req)
        res = self._session.send(req)
        self.log_response(res)

        if not res.ok:
            raise self.AuthenticationError()

    def request_rdp_session(self):
        domain_b64 = base64.b64encode(bytes(self._domain, "utf-8")).decode()
        url = f"https://portal.l3t.com/f5vdi/rdp/launch/Portal_L3T/Enterprise_Remote_Desktop?{domain_b64}"

        req = requests.Request("GET", url)
        req = self._session.prepare_request(req)

        self.log_request(req)
        res = self._session.send(req)
        self.log_response(res, log_content=True)

        if not res.ok:
            raise self.RDPRequestError()

        return RDPParser.parse(res.content.decode())

    def _load_cache(self):
        if not self._cache.exists or not self._cache.is_file():
            return False

        with self._cache.open() as f:
            try:
                cookies = json.loads(f.read())
                self._session.cookies.update(
                    requests.utils.cookiejar_from_dict(cookies)
                )
            except json.decoder.JSONDecodeError:
                return False

        return True

    def _save_cache(self):
        with self._cache.open("w") as f:
            f.write(json.dumps(self._session.cookies.get_dict()))

    def connect(self):
        if self._load_cache():
            try:
                return self.request_rdp_session()
            except self.RDPRequestError:
                self._session.cookies.clear()

        self.initialize()
        self.authenticate()

        self._save_cache()

        return self.request_rdp_session()


def main():
    args = parse_args()

    if args.config is None:
        args.config = get_config_path()

    ui = UI(debug=args.verbose)
    ctx = load_context(ui, args.config)

    if args.freerdp:
        ctx.freerdp = args.freerdp
    if args.domain:
        ctx.domain = args.domain

    cache = get_cache_path()

    if not ctx.domain:
        ctx.domain = ui.input("Enter domain: ")

    session = PortalSession(domain=ctx.domain, cache=cache)
    session.set_log_request_callback(ui.log_request)
    session.set_log_response_callback(ui.log_response)
    session.set_authentication_info_callback(LoadAuthenticationInfo(ui, ctx))

    try:
        rdp_settings = session.connect()
    except PortalSession.RDPRequestError:
        ui.fatal("Failed to authenticate.")


    if not ctx.smartcard_pin:
        ctx.smartcard_pin = ui.getpass("Enter smartcard pin: ")

    rdp_settings.fullscreen = True
    rdp_settings.clipboard = True
    rdp_settings.floatbar = RDPSessionSettings.Floatbar(sticky=False)
    rdp_settings.security_protocol = RDPSessionSettings.SecurityProtocol.RDP
    rdp_settings.smartcard = RDPSessionSettings.Smartcard()
    rdp_settings.smartcard_logon = RDPSessionSettings.SmartcardLogon(
        pin=ctx.smartcard_pin
    )

    rdp_session = FreeRDPSession(rdp_settings, freerdp_exec=ctx.freerdp)

    ui.info("Launching RDP session.")
    ui.log_exec(" ".join(rdp_session.command))

    rdp_session.launch()


def get_config_path():
    config = Path("l3-remote-desktop/l3-remote-desktop.yml")

    if "XDG_CONFIG_HOME" in os.environ:
        return Path(os.environ["XDG_CONFIG_HOME"]) / config
    else:
        return Path("~/.config").expanduser() / config


def get_cache_path():
    cache = "l3-remote-desktop.json"

    if "XDG_CACHE_HOME" in os.environ:
        return Path(os.environ["XDG_CACHE_HOME"]) / cache
    else:
        return Path("~/.cache").expanduser() / cache


def load_context(ui, config):
    if not config.exists() or not config.is_file():
        return Context()

    with config.open() as f:
        try:
            data = yaml.safe_load(f.read())
        except yaml.scanner.ScannerError as e:
            print(e, file=sys.stderr)
            ui.fatal(f"Failed reading config: {config}")

    return Context(**data)


class LoadAuthenticationInfo:
    def __init__(self, ui, ctx):
        self._ui = ui
        self._ctx = ctx

    def __call__(self):
        if self._ctx.username is None:
            self._ctx.username = self._ui.input("Enter username: ")
        if self._ctx.password is None:
            self._ctx.password = self._ui.getpass("Enter password: ")
        if self._ctx.rsa_pin is None:
            self._ctx.rsa_pin = self._ui.getpass("Enter RSA pin: ")
        if self._ctx.token is None:
            self._ctx.token = self._ui.input("Enter RSA token: ")

        return PortalSession.AuthenticationInfo(
            self._ctx.username,
            self._ctx.password,
            self._ctx.rsa_pin,
            self._ctx.token,
        )


def load_user_info(ui, ctx):
    if ctx.username is None:
        ctx.username = ui.input("Enter username: ")
    if ctx.domain is None:
        ctx.domain = ui.input("Enter domain: ")
    if ctx.password is None:
        ctx.password = ui.getpass("Enter password: ")
    if ctx.smartcard_pin is None:
        ctx.smartcard_pin = ui.getpass("Enter smartcard pin: ")
    if ctx.rsa_pin is None:
        ctx.rsa_pin = ui.getpass("Enter RSA pin: ")
    if ctx.token is None:
        ctx.token = ui.input("Enter RSA token: ")


def parse_args():
    parser = argparse.ArgumentParser(
        prog="L3Harris Remote Desktop",
        description="Launch remote desktop session.",
    )

    parser.add_argument("-c", "--config", type=Path, help="Path to configuration file.")
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Enable verbose output."
    )
    parser.add_argument("--freerdp", help="Name of FreeRDP executable.")
    parser.add_argument("--domain", "-d", help="RDP Domain.")

    return parser.parse_args()


if __name__ == "__main__":
    main()
